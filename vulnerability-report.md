# Audit report for ECOM CupCakes shop based on OWASP assessment list

## Insecure Direct object references
Always check whether the user identity matches with a requested resource identifier.

DO NOT do this:

```
public async Task<IActionResult> Details(string userId)
{
    var user = _context.Users.Where(u => u.ID == userId).ToListAsync()[0];
    return View(user);
}
```

DO THAT:

```
public async Task<IActionResult> Details(string userId)
{
    var user = _context.Users.Where(u => u.ID == userId).ToListAsync()[0];
    var userIdentityId = _userManager.GetUserId(Httpcontext.User);
    if(user.ID != userIdentityId)
        return NotFound();
    return View(user);
}
```

The ECOM project doesn't contain code where it looks for a user information based on the provided id. All methods in 'profile' section take current user from an identity storage using current HttpContext. It means that the treat is eliminated.

For example:

```
        public async Task OnGetAsync()
        {
            _user = await _userManager.GetUserAsync(HttpContext.User);
            Orders = await _order.GetOrders(_user.Id, 5);
        }
```

## Cross site request forgery

Use anti-forgery token for any Post/Put requests from the Front-end.

Add to any form in a project Taghelpers or Htmlhelpers

```
<form>
    <div asp-validation-summary="All" class="text-danger"></div>
</form>
```
or
```
using (Html.BeginForm() {
    @Html.AntiForgeryToken()
}
```

Add on a server side special attribute - `[ValidateAntiForgeryToken]`. And remove all validation tokens on logout.

The project contains three forms along with corresponding controllers:

Account (to register/login a user);
Basket (for modifying quantity of products in a basket);
Checkout (to collect user address data);

Only Account contorller and forms have antiforgery attributes/validation. Both Basket and Checkout are vulnurable to CSRF attack. Suggestion: add validation to all forms/controllers.



## Sensitive data exposure
Sensitive data exposure is the use/manipulation of data which is not secure. Such case is when data that is sensitive lacks encryption, or when data is transmited unsecurely. Another case is when passwords are stored encrypted, as that means it can be descrypted.

Sensitive data exposure could affect our users by exposing sensitive location information related to their order during a SQL injection attack. If we stored passwords instead of their hashes, we would be exposing sensitive user data to potential attackers.

Repair
Ensure we are using a TLS on our web site with a strong policy. Use AES-512 encryption to protect identifiable data. We could use a stored procedure or create a custom field with Entity Framework. We could accomplish this by overriding the Getter/Setter methods in the specific property we need encrypted.

DON'T DO:

	public string CreditCard {get; set;}


DO:

Modifying Address field in order Model:

`public string Address { get => Decrypt(secret);  set => Encrypt(secret, value);}`


## SQL Injection
Exposure
SQL Injection is when malicious code is inserted into strings. These strings contain SQL syntax terminating characters which allow the attacker to 'inject' additional SQL statements.

SQL Injection could allow a attacker to view data on our customers, or potentially place orders with a cost of $0.

DON'T DO:

`  string strQry = "SELECT * FROM Users WHERE UserName='" + txtUser.Text + "' AND Password='" + txtPassword.Text + "'";
   EXEC strQry // SQL Injection vulnerability!
`

DO:

`  var sql = @"Update [User] SET FirstName = @FirstName WHERE Id = @Id";
   context.Database.ExecuteSqlCommand(
      sql,
      new SqlParameter("@FirstName", firstname),
      new SqlParameter("@Id", id));`

Repair
Our website is secure against SQL injection because we use Entity Framework to execute all our queries represented underneath as parameterized queries. Where ever we use LINQ, it is also safe against SQL injection as LINQ -> Entities queries don't use string concatenation.